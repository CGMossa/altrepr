---
title: "Compact Sequences"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{compact_seq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Background

Let's learn about `altrepr` by looking at the "compact sequences", perhaps the most famous 
ALTREP class in R.

Compact sequences [were introduced in R 3.5.0](https://cran.r-project.org/bin/windows/base/old/3.5.0/NEWS.R-3.5.0.html).
They are simply integer (or double) vectors that are represented as a "range": they store the start, length, and step of a sequence, rather than storing every individual element in that range, which can save a lot of memory. Compact sequences are created by the `:` operator, and by the `seq` family of functions. Let's investigate this class using altrepr!

# The Tip of the Iceberg

To start we need to load the `altrepr` package:

```{r setup}
library(altrepr)
```

Firstly, we can use the `is_altrep` class to distinguish between ALTREP and 
ordinary vectors:

```{r}
is_altrep(c(1, 2, 3))
```
```{r}
is_altrep(1:3)
```
```{r}
is_altrep(seq(1, 3))
```

We can get the ALTREP classname using `alt_classname`:

```{r}
alt_classname(1:3)
```

We can find out where the ALTREP class was defined using `alt_pkgname`:

```{r}
alt_pkgname(1:3)
```

# Function Naming Scheme

Functions in `altrepr` starting with `alt_` or `is_alt_` relate to any ALTREP class.
More specific ALTREP classes have their own utility functions. 
For compact vectors, this prefix is `compact_`.

The first example we will see of this is a simple check for compact vectors:

```{r}
is_compact_vec(1:3)
```

```{r}
is_compact_vec(c(1, 2))
```

# Coercing to a Standard Integer Vector

The ALTREP API doesn't currently provide a function for forcing an ALTREP vector
to be converted to it's standard representation form, but compact vectors can be
expanded just using an empty index: `[]`.

We can use this feature to prove the value of the compact sequence class, 
by comparing the memory usage of a traditional integer vector, and the compact version:

Let's start with an enormous vector:
```{r}
x <- 1:10^9
is_altrep(x)
```

But even with 100 million elements, it's actually not very big!
```{r}
lobstr::obj_size(x)
```

Now let's force the vector to expand. You will notice that this seemingly simple
operation actually takes suspiciously long. This is of course because a 1 billion element
standard representation vector is being generated behind the scenes:
```{r}
system.time({
  y <- x[]
})
```
```{r}
is_altrep(y)
```


```{r}
lobstr::obj_size(y)
```

There we go. It's no longer ALTREP, and we've worked out that we saved about 4 GB by 
using ALTREP!

# ALTREP Data

ALTREP classes have two "slots" for storing data (not the same as S4 slots, but it's a helpful
analogy). These are respectively called `data1` and `data2`.
These slots can store any type of R object, including
recursive types like lists, so this isn't really a restriction. 

## `data1`

In the case of compact sequences, `data1` is used to store the parameters
of the sequence as an integer vector

* The first entry contains the length of the sequence
* The second entry contains the start value of the sequence
* The third entry contains the step, which is currently always 1 or -1

We can prove all this using the `alt_data1()` function:

```{r}
alt_data1(1:3)
```

```{r}
alt_data1(2:3)
```

```{r}
alt_data1(3:2)
```

Actually `altrepr` has a utility function for finding this information, specifically for compact vectors:

```{r}
compact_fields(4:2)
```


## `data2` and the Expanded Form
Compact seqs are considered to start in "compact" form, which we can see at the very end of the output from `alt_inspect`. 
This function prints some internal information about the altrep vector which often seems to be informative when dealing with built-in ALTREP types:

```{r}
x <- 1:3
alt_inspect(x)
```

"compact" means that `data2` is `NULL`, which is its initial value:

```{r}
alt_data2(x)
```

A shortcut method to check for this is `compact_is_expanded`:

```{r}
compact_is_expanded(x)
```

When the `DATAPTR` of the sequence is accessed (which is a pointer to the array of data in the vector), it forces the compact sequence to expand.
`altrepr` has a special built-in function that forces a compact vector to expand without any other side effects:

```{r}
compact_expand(x)
alt_inspect(x)
```

```{r}
compact_is_expanded(x)
```


Notably `x` is *still* ALTREP, it hasn't been coerced into a standard representation vector:
```{r}
is_altrep(x)
```

But the `data2` value, which is linked to the expanded form, is now set to a full vector of integer data:

```{r}
alt_data2(x)
```
