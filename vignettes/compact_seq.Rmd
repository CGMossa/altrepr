---
title: "compact_seq"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{compact_seq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(altrepr)
```

# Compact Sequences

Let's start by looking at the "compact sequence", perhaps the most famous 
ALTREP class in R.

Compact sequences [were introduced in R 3.5.0](https://cran.r-project.org/bin/windows/base/old/3.5.0/NEWS.R-3.5.0.html).
They are simply simply integer (or double) vectors that, rather than storing every individual value in a given range, instead store the start and end of the range, which can save a lot of memory.

They are created by the `:` operator, and by the `seq` family of functions.

Let's investigate this class using altrepr!

# The Tip of the Iceberg

Firstly, we can use the `is_altrep` class to distinguish between ALTREP and 
ordinary vectors:

```{r}
is_altrep(c(1, 2, 3))
```
```{r}
is_altrep(1:3)
```
```{r}
is_altrep(seq(1, 3))
```

We can get the ALTREP classname using `alt_classname`:

```{r}
alt_classname(1:3)
```

We can find out where the ALTREP class was defined using `alt_pkgname`:

```{r}
alt_pkgname(1:3)
```

# Coercing to a Standard Integer Vector

The ALTREP API doesn't currently provide a function for forcing an ALTREP vector
to be converted to it's standard representation form, but compact vectors can be
expanded just by mutating them at all, since this prevents them from being 
represented compactly.

We can use this feature to prove the value of the compact sequence class, 
by comparing the memory usage of a traditional integer vector, and the compact version:

Let's start with an enormous vector:
```{r}
x <- 1:10^8
is_altrep(x)
```

But even with 100 million elements, it's actually not very big!
```{r}
lobstr::obj_size(x)
```

Now let's force the vector to expand. You will notice that this seemingly simple
operation actually takes suspiciously long. This is of course because an 100 million
standard representation vector is being generated behind the scenes:
```{r}
system.time({
  x[2] <- 1
})
```
```{r}
is_altrep(x)
```


```{r}
lobstr::obj_size(x)
```

There we go. It's no longer ALTREP, and we've worked out that we saved about 800 MB by 
using ALTREP!

# ALTREP Data

ALTREP classes have two "slots" (not the same as S4 slots, but it's a helpful
analogy) for storing data. These are respectively called `data1` and `data2`.
These slots can store any type of R object, including
recursive types like lists, so this isn't really a restriction. 

In the case of compact sequences, `data1` is used to store the parameters
of the sequence as an integer vector

* The first entry contains the length of the sequence
* The second entry contains the start value of the sequence
* The third entry contains the step, which is currently always 1 or -1

We can prove all this using the `alt_data1()` function:

```{r}
alt_data1(1:3)
```

```{r}
alt_data1(2:3)
```

```{r}
alt_data1(3:2)
```

```{r}
alt_data2(1:3)
```



In this case, `data2` is often `NULL` until the
//' type is expanded. For example `1:3` is an ALTREP that represents
//' `c(1L, 2L, 3L)` in a compressed way. `altrep_data1(1:3)` returns
//' `3 1 1`, which indicates the length of the sequence, the start of the sequence, and the dierction in which it runs
